/*
 * Copyright (c) 2019 ChainFront LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package pcrypto.cf.docs

import com.fasterxml.jackson.core.JsonProcessingException
import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.databind.node.JsonNodeFactory
import com.fasterxml.jackson.databind.node.ObjectNode
import com.fasterxml.jackson.databind.node.TextNode
import org.slf4j.LoggerFactory
import org.springframework.core.MethodParameter
import org.springframework.http.MediaType
import org.springframework.http.converter.HttpMessageConverter
import org.springframework.http.server.ServerHttpRequest
import org.springframework.http.server.ServerHttpResponse
import org.springframework.web.bind.annotation.ControllerAdvice
import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice
import springfox.documentation.spring.web.json.Json
import springfox.documentation.swagger2.web.Swagger2Controller
import java.util.*


/**
 * This advice object is necessary to hook into the autogenerated swagger.json and do certain post-processing
 * steps. This is required because springfox doesn't always enable enough hooks.
 *
 *  * Make method names not look dumb (they currently have "_1" at the end of them). Basically, it will scan the
 * swagger document structure and replace all the operationId node values
 * that have "_?" in them with a sanitized form.
 *
 *  * Order the tags. For some unknown reason, springfox/swagger doesn't like ordering. So this is the only
 * way to avoid the HashSet they use for all their data structures.
 *
 *
 */
@ControllerAdvice(assignableTypes = [Swagger2Controller::class])
class SwaggerPostProcessorAdvice : ResponseBodyAdvice<Any> {

    override fun supports(
        returnType: MethodParameter,
        converterType: Class<out HttpMessageConverter<*>>
    ): Boolean {
        return true
    }


    override fun beforeBodyWrite(
        body: Any?,
        returnType: MethodParameter,
        selectedContentType: MediaType,
        selectedConverterType: Class<out HttpMessageConverter<*>>,
        request: ServerHttpRequest,
        response: ServerHttpResponse
    ): Any? {
        try {
            val objectMapper = ObjectMapper()
            val document = objectMapper.readTree((body as Json).value())

            //            this.sanitize( document, "operationId" );

            //            this.orderTags( objectMapper, document, "tags" );

            //            this.addLogoUrl( document, "info" );

            this.addTagGroups(document)

            return document
        } catch (e: Exception) {
            log.error("Exception during post-processing of swagger.json file", e)
            return body
        }

    }


    /**
     * Add Redoc supported vendor extension properties such as x-logo.
     *
     * @param parent    parent node
     * @param fieldName name of field to append to
     * @throws JsonProcessingException json processing exception
     */
    private fun addLogoUrl(
        parent: JsonNode,
        fieldName: String
    ) {
        if (parent.has(fieldName)) {
            val infoNode = parent.get(fieldName)

            val logoNode = JsonNodeFactory.instance.objectNode()
            logoNode.put("url", "/image/CF-developer-purple.png")
            (infoNode as ObjectNode).set("x-logo", logoNode)
        }
    }


    @Throws(JsonProcessingException::class)
    private fun addTagGroups(parent: JsonNode) {
        // Accounts Tag Group
        val accountTags = JsonNodeFactory.instance.arrayNode()
        accountTags.add(SwaggerTags.ACCOUNTS)

        val accountGroup = JsonNodeFactory.instance.objectNode()
        accountGroup.put("name", "ACCOUNTS")
        accountGroup.putArray("tags").addAll(accountTags)


        // Stellar Group
        val stellarTags = JsonNodeFactory.instance.arrayNode()
        stellarTags.add(SwaggerTags.STELLAR_ACCOUNTS)
        stellarTags.add(SwaggerTags.STELLAR_TRANSACTIONS)

        val stellarGroup = JsonNodeFactory.instance.objectNode()
        stellarGroup.put("name", "STELLAR")
        stellarGroup.putArray("tags").addAll(stellarTags)

        // Ripple Group
        val rippleTags = JsonNodeFactory.instance.arrayNode()
        rippleTags.add(SwaggerTags.RIPPLE_ACCOUNTS)
        rippleTags.add(SwaggerTags.RIPPLE_TRANSACTIONS)

        val rippleGroup = JsonNodeFactory.instance.objectNode()
        rippleGroup.put("name", "RIPPLE")
        rippleGroup.putArray("tags").addAll(rippleTags)

        // Ethereum group
        val ethereumTags = JsonNodeFactory.instance.arrayNode()
        ethereumTags.add(SwaggerTags.ETH_ACCOUNTS)
        ethereumTags.add(SwaggerTags.ETH_CONTRACTS)
        ethereumTags.add(SwaggerTags.ETH_TRANSACTIONS)

        val ethereumGroup = JsonNodeFactory.instance.objectNode()
        ethereumGroup.put("name", "ETHEREUM")
        ethereumGroup.putArray("tags").addAll(ethereumTags)

        // Bitcoin Group
        val bitcoinTags = JsonNodeFactory.instance.arrayNode()
        bitcoinTags.add(SwaggerTags.BITCOIN_ACCOUNTS)
        bitcoinTags.add(SwaggerTags.BITCOIN_TRANSACTIONS)

        val bitcoinGroup = JsonNodeFactory.instance.objectNode()
        bitcoinGroup.put("name", "BITCOIN")
        bitcoinGroup.putArray("tags").addAll(bitcoinTags)

        val groups = ArrayList<ObjectNode>()
        groups.add(accountGroup)
        groups.add(stellarGroup)
        groups.add(rippleGroup)
        groups.add(ethereumGroup)
        groups.add(bitcoinGroup)

        (parent as ObjectNode).putArray("x-tagGroups").addAll(groups)
    }


    private fun sanitize(
        parent: JsonNode,
        fieldName: String
    ) {
        if (parent.has(fieldName)) {
            val text = parent.get(fieldName).textValue()
            if (null != text) {
                val pos = text.indexOf("_")
                if (pos > -1) {
                    (parent as ObjectNode).set(fieldName, TextNode(text.substring(0, pos)))
                }
            }
        }

        for (child in parent) {
            this.sanitize(child, fieldName)
        }
    }

    companion object {
        private val log = LoggerFactory.getLogger(SwaggerPostProcessorAdvice::class.java)
    }
}
